package com.example.routinehero;

import android.content.Context;
import android.content.SharedPreferences;
import android.widget.Toast;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;

public class RoutineManager {
    private static ArrayList<Routine> routines = new ArrayList<>();
    private static int currentLevel = 1;
    private static int consecutiveDays = 0;
    private static final int[] REQUIRED_ROUTINES = {1, 1, 1, 2, 2, 2, 3, 3, 4, 5};//*/{1, 2, 3, 4, 5, 5, 5, 5, 5, 5};
    public static final int[] DAYS_NEEDED ={1, 1, 1, 2, 2, 2, 3, 3, 4, 5};//{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};//*/ {7, 7, 7, 7, 7, 14, 20, 30, 40, 50};
    private static int currentId = 0;
    private static int currentTestDay = 0;
    private static boolean todayRoutinesCompleted = false;
    private static final int MAX_LEVEL = 10;
    private static boolean isMaxLevelAchieved = false;
    
    // SharedPreferences í‚¤ ìƒìˆ˜
    private static final String PREFS_NAME = "RoutineHeroPrefs";
    private static final String KEY_ROUTINES = "routines";
    private static final String KEY_CURRENT_LEVEL = "currentLevel";
    private static final String KEY_CONSECUTIVE_DAYS = "consecutiveDays";
    private static final String KEY_CURRENT_ID = "currentId";
    private static final String KEY_CURRENT_TEST_DAY = "currentTestDay";
    private static final String KEY_TODAY_ROUTINES_COMPLETED = "todayRoutinesCompleted";
    private static final String KEY_IS_MAX_LEVEL_ACHIEVED = "isMaxLevelAchieved";
    private static final String KEY_LAST_SAVE_DATE = "lastSaveDate";
    
    private static Context context;
    private static Gson gson = new Gson();

    // Context ì´ˆê¸°í™” ë©”ì„œë“œ
    public static void initialize(Context ctx) {
        context = ctx;
        loadData();
    }

    // ë°ì´í„° ì €ì¥ ë©”ì„œë“œ
    public static void saveData() {
        if (context == null) return;
        
        SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = prefs.edit();
        
        // ë£¨í‹´ ë°ì´í„°ë¥¼ JSONìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥
        String routinesJson = gson.toJson(routines);
        editor.putString(KEY_ROUTINES, routinesJson);
        
        // ê¸°íƒ€ ë°ì´í„° ì €ì¥
        editor.putInt(KEY_CURRENT_LEVEL, currentLevel);
        editor.putInt(KEY_CONSECUTIVE_DAYS, consecutiveDays);
        editor.putInt(KEY_CURRENT_ID, currentId);
        editor.putInt(KEY_CURRENT_TEST_DAY, currentTestDay);
        editor.putBoolean(KEY_TODAY_ROUTINES_COMPLETED, todayRoutinesCompleted);
        editor.putBoolean(KEY_IS_MAX_LEVEL_ACHIEVED, isMaxLevelAchieved);
        editor.putLong(KEY_LAST_SAVE_DATE, System.currentTimeMillis());
        
        editor.apply();
    }

    // ë°ì´í„° ë¡œë“œ ë©”ì„œë“œ
    public static void loadData() {
        if (context == null) return;
        
        SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
        
        // ë£¨í‹´ ë°ì´í„° ë¡œë“œ
        String routinesJson = prefs.getString(KEY_ROUTINES, "");
        if (!routinesJson.isEmpty()) {
            Type listType = new TypeToken<ArrayList<Routine>>(){}.getType();
            ArrayList<Routine> loadedRoutines = gson.fromJson(routinesJson, listType);
            if (loadedRoutines != null) {
                routines = loadedRoutines;
            }
        }
        
        // ê¸°íƒ€ ë°ì´í„° ë¡œë“œ
        currentLevel = prefs.getInt(KEY_CURRENT_LEVEL, 1);
        consecutiveDays = prefs.getInt(KEY_CONSECUTIVE_DAYS, 0);
        currentId = prefs.getInt(KEY_CURRENT_ID, 0);
        currentTestDay = prefs.getInt(KEY_CURRENT_TEST_DAY, 0);
        todayRoutinesCompleted = prefs.getBoolean(KEY_TODAY_ROUTINES_COMPLETED, false);
        isMaxLevelAchieved = prefs.getBoolean(KEY_IS_MAX_LEVEL_ACHIEVED, false);
    }

    // ë‚ ì§œ ë³€ê²½ ì²´í¬ ë° ìë™ ì €ì¥
    public static void checkDateChange() {
        if (context == null) return;
        
        SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
        long lastSaveDate = prefs.getLong(KEY_LAST_SAVE_DATE, 0);
        long currentDate = System.currentTimeMillis();
        
        // í•˜ë£¨ê°€ ì§€ë‚¬ëŠ”ì§€ í™•ì¸ (86400000ms = 24ì‹œê°„)
        if (currentDate - lastSaveDate >= 86400000) {
            // ìƒˆë¡œìš´ ë‚ ì´ë¯€ë¡œ ë£¨í‹´ ì™„ë£Œ ìƒíƒœ ì´ˆê¸°í™”
            resetDayProgress();
            todayRoutinesCompleted = false;
            
            // ì‹¤ì œ ë‚ ì§œ ê¸°ë°˜ ë ˆë²¨ ì§„í–‰ìƒí™© ì²´í¬
            checkLevelProgress();
            
            saveData();
        }
    }
    
    // ì‹¤ì œ ë‚ ì§œ ê¸°ë°˜ ë ˆë²¨ ì§„í–‰ìƒí™© ì²´í¬
    private static void checkLevelProgress() {
        if (todayRoutinesCompleted) {
            consecutiveDays++;
            if (consecutiveDays >= DAYS_NEEDED[currentLevel - 1]) {
                if (currentLevel < MAX_LEVEL) {
                    levelUp();
                } else if (currentLevel == MAX_LEVEL && !isMaxLevelAchieved) {
                    // ì²˜ìŒ ìµœëŒ€ ë ˆë²¨ ë‹¬ì„± ì‹œ
                    isMaxLevelAchieved = true;
                }
                // ìµœëŒ€ ë ˆë²¨ì—ì„œëŠ” ì—°ì† ì¼ìˆ˜ë¥¼ DAYS_NEEDEDì˜ ë§ˆì§€ë§‰ ê°’ìœ¼ë¡œ ê³ ì •
                if (currentLevel == MAX_LEVEL) {
                    consecutiveDays = DAYS_NEEDED[MAX_LEVEL - 1];
                }
            }
        } else {
            if (currentLevel > 1) {
                currentLevel--;
            }
            consecutiveDays = 0;
        }
    }

    public static void addRoutine(String name) {
        Routine routine = new Routine(++currentId, name);
        routines.add(routine);
        saveData(); // ë°ì´í„° ì €ì¥
    }

    // ë£¨í‹´ ì‚­ì œ ë©”ì†Œë“œ ì¶”ê°€
    public static void removeRoutine(Routine routine) {
        routines.remove(routine);
        saveData(); // ë°ì´í„° ì €ì¥
    }

    public static ArrayList<Routine> getRoutines() {
        return new ArrayList<>(routines);
    }

    public static void saveCompletedRoutines(List<Routine> completedRoutines) {
        // í˜„ì¬ ë£¨í‹´ë“¤ì˜ ì™„ë£Œ ìƒíƒœ ì—…ë°ì´íŠ¸
        for (Routine routine : routines) {
            routine.setCompleted(false);
        }

        // ì™„ë£Œëœ ë£¨í‹´ ì²´í¬
        for (Routine completed : completedRoutines) {
            for (Routine routine : routines) {
                if (routine.getId() == completed.getId()) {
                    routine.setCompleted(true);
                    break;
                }
            }
        }

        // ì˜¤ëŠ˜ì˜ ëª©í‘œ ë‹¬ì„± ì—¬ë¶€ ì²´í¬
        int completedCount = getCompletedRoutinesCount();
        int requiredRoutines = REQUIRED_ROUTINES[currentLevel - 1];
        todayRoutinesCompleted = completedCount >= requiredRoutines;
        
        saveData(); // ë°ì´í„° ì €ì¥
    }

    public static void incrementTestDay(Context context) {
        // ë‚ ì§œê°€ ë³€ê²½ë  ë•Œ ë ˆë²¨ ì§„í–‰ìƒí™© ì²´í¬
        if (todayRoutinesCompleted) {
            consecutiveDays++;
            if (consecutiveDays >= DAYS_NEEDED[currentLevel - 1]) {
                if (currentLevel < MAX_LEVEL) {
                    levelUp();
                    Toast.makeText(context, "ë ˆë²¨ ì—…!", Toast.LENGTH_SHORT).show();
                } else if (currentLevel == MAX_LEVEL && !isMaxLevelAchieved) {
                    // ì²˜ìŒ ìµœëŒ€ ë ˆë²¨ ë‹¬ì„± ì‹œ
                    isMaxLevelAchieved = true;
                    Toast.makeText(context, "ì¶•í•˜í•©ë‹ˆë‹¤! ìµœê³  ë ˆë²¨ì„ ë‹¬ì„±í–ˆìŠµë‹ˆë‹¤! ğŸ‰", Toast.LENGTH_LONG).show();
                } else {
                    // ìµœëŒ€ ë ˆë²¨ì´ê³  ë£¨í‹´ì„ ì˜ ìˆ˜í–‰í•œ ê²½ìš°
                    Toast.makeText(context, "ì™„ë²½í•œ í•˜ë£¨ì˜€ìŠµë‹ˆë‹¤! â­", Toast.LENGTH_SHORT).show();
                }
                // ìµœëŒ€ ë ˆë²¨ì—ì„œëŠ” ì—°ì† ì¼ìˆ˜ë¥¼ DAYS_NEEDEDì˜ ë§ˆì§€ë§‰ ê°’ìœ¼ë¡œ ê³ ì •
                if (currentLevel == MAX_LEVEL) {
                    consecutiveDays = DAYS_NEEDED[MAX_LEVEL - 1];
                }
            }
        } else {
            if (currentLevel > 1) {
                currentLevel--;
                Toast.makeText(context, "ì˜¤ëŠ˜ì˜ ëª©í‘œë¥¼ ë‹¬ì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë ˆë²¨ ë‹¤ìš´...", Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(context, "ì˜¤ëŠ˜ì˜ ëª©í‘œë¥¼ ë‹¬ì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ê¾¸ì¤€íˆ ë£¨í‹´ì„ ë‹¬ì„±í•´ì£¼ì„¸ìš”!", Toast.LENGTH_SHORT).show();
            }
            consecutiveDays = 0;
        }

        // ìƒˆë¡œìš´ ë‚ ì„ ìœ„í•œ ì´ˆê¸°í™”
        currentTestDay++;
        todayRoutinesCompleted = false;
        resetDayProgress();
        
        saveData(); // ë°ì´í„° ì €ì¥
    }

    public static void decrementTestDay() {
        if (currentTestDay > 0) {
            currentTestDay--;
            todayRoutinesCompleted = false;
            resetDayProgress();
            saveData(); // ë°ì´í„° ì €ì¥
        }
    }

    private static void resetDayProgress() {
        for (Routine routine : routines) {
            routine.setCompleted(false);
        }
    }

    private static void levelUp() {
        if (currentLevel < MAX_LEVEL) {
            currentLevel++;
            consecutiveDays = 0;
        }
    }

    public static int getCurrentLevel() {
        return currentLevel;
    }

    public static int getCurrentTestDay() {
        return currentTestDay;
    }

    public static int getDaysNeededForNextLevel() {
        if (currentLevel >= 1 && currentLevel <= MAX_LEVEL) {
            return DAYS_NEEDED[currentLevel - 1] - consecutiveDays;
        }else if(isMaxLevelAchieved){
            return 0;
        }
        return 0;
    }

    public static int getCompletedRoutinesCount() {
        return (int) routines.stream()
                .filter(Routine::isCompleted)
                .count();
    }

    public static int getRequiredRoutinesForCurrentLevel() {
        return REQUIRED_ROUTINES[currentLevel - 1];
    }
}